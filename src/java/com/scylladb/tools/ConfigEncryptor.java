/*
 * Copyright (C) 2018 ScyllaDB
 *
 */

/*
 * This file is part of Scylla.
 *
 * See the LICENSE.PROPRIETARY file in the top-level directory for licensing information.
 */

package com.scylladb.tools;

import static com.scylladb.tools.LocalFileKeyGenerator.getSystemKeyDir;
import static java.lang.Boolean.valueOf;
import static java.nio.file.Files.readAllBytes;
import static java.nio.file.attribute.PosixFilePermission.OWNER_READ;
import static java.nio.file.attribute.PosixFilePermission.OWNER_WRITE;
import static java.nio.file.attribute.PosixFilePermissions.asFileAttribute;
import static java.util.EnumSet.of;
import static javax.crypto.Cipher.DECRYPT_MODE;
import static javax.crypto.Cipher.ENCRYPT_MODE;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintStream;
import java.io.StringReader;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;
import java.util.Base64;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.crypto.Cipher;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import org.apache.cassandra.exceptions.ConfigurationException;
import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.GnuParser;
import org.apache.commons.cli.HelpFormatter;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;
import org.yaml.snakeyaml.Yaml;
import org.yaml.snakeyaml.events.Event;
import org.yaml.snakeyaml.events.Event.ID;
import org.yaml.snakeyaml.events.ScalarEvent;

import com.google.common.annotations.VisibleForTesting;

/**
 * Tool to encrypt sensitive parts of scylla config using a system key.
 * 
 * @author calle
 *
 */
public class ConfigEncryptor {
    @VisibleForTesting
    public static final String COM_SCYLLADB_SCYLLA_YAML = "com.scylladb.ScyllaYaml";
    @VisibleForTesting
    public static final String GENERATED_BY_CONFIG_ENCRYPTOR = "\n\n# Generated by config encryptor\n";
    @VisibleForTesting
    public static final String TOOL_NAME = "configuration_encryptor";
    @VisibleForTesting
    public static final String DEFAULT_SCYLLA_YAML = System.getProperty(COM_SCYLLADB_SCYLLA_YAML, "conf/scylla.yaml");

    @VisibleForTesting
    public static final String[] ENCRYPTED_ENTRIES = { "password" };

    @VisibleForTesting
    public static final String CONFIG_ENCRYPTION_ACTIVE = "config_encryption_active";
    @VisibleForTesting
    public static final String CONFIG_ENCRYPTION_KEY_NAME = "config_encryption_key_name";

    private static void printUsage(Options options) {
        String usage = String.format("%s [options] [key path]", TOOL_NAME);
        String header = System.lineSeparator()
                + "Encrypt sensitive scylla configuration entries using system key at <key path>.";
        String footer = System.lineSeparator() + "(Requires Java cryptographic extensions)";
        new HelpFormatter().printHelp(usage, header, options, footer);
    }

    private static File resolveSystemKey(String fileOrDir) {
        File keyFile = new File(fileOrDir);
        String keyName = "system_key";
        if (!keyFile.exists() && !keyFile.isDirectory()
                && (keyFile.getParentFile() == null || !keyFile.getParentFile().isDirectory())) {
            keyName = keyFile.getName();
            keyFile = new File(getSystemKeyDir());
        }
        if (keyFile.isDirectory()) {
            keyFile = new File(keyFile, keyName);
        }
        return keyFile;
    }

    private static Cipher loadSystemKey(File keyFile) throws NoSuchAlgorithmException, NoSuchPaddingException,
            InvalidKeyException, IOException, InvalidAlgorithmParameterException {
        return loadSystemKey(keyFile, ENCRYPT_MODE);
    }

    private static Cipher loadSystemKey(File keyFile, int cipherMode) throws NoSuchAlgorithmException,
            NoSuchPaddingException, InvalidKeyException, IOException, InvalidAlgorithmParameterException {
        if (!keyFile.isFile() || !keyFile.canRead()) {
            throw new ConfigurationException("Cannot read " + keyFile);
        }

        Pattern p = Pattern.compile("^(\\w+)/(\\w+)/(\\w+):(\\d+):(\\S+)$");
        Cipher cipher = null;

        try (BufferedReader r = new BufferedReader(new FileReader(keyFile))) {
            String line;
            while ((line = r.readLine()) != null) {
                line = line.trim();
                if (line.startsWith("#")) {
                    continue;
                }
                Matcher m = p.matcher(line);
                if (m.matches()) {
                    String alg = m.group(1);
                    String mode = m.group(2);
                    String padd = m.group(3);
                    String data = m.group(5);

                    byte[] bytes = Base64.getDecoder().decode(data);
                    SecretKeySpec spec = new SecretKeySpec(bytes, 0, bytes.length, alg);

                    cipher = Cipher.getInstance(alg + "/" + mode + "/" + padd);

                    /**
                     * Dse uses random (per-value) IV and then prepends this IV
                     * to the resulting bytes. This is not good iv management.
                     * 
                     * We use another not-ideal variant, where the sha-256 of
                     * the key bytes is IV (for all). The upside of this is that
                     * we thus hang the whole encryption on the key and its
                     * protection. And we don't leave traces of the encryption
                     * process in clear text.
                     */
                    int blockSize = cipher.getBlockSize();
                    MessageDigest digest = MessageDigest.getInstance("SHA-256");
                    byte[] ivbytes = Arrays.copyOf(digest.digest(bytes), blockSize);

                    cipher.init(cipherMode, spec, new IvParameterSpec(ivbytes));
                    break;
                }
            }
        }

        if (cipher == null) {
            throw new ConfigurationException("Could not read key file: " + keyFile);
        }
        return cipher;
    }

    public static void main(String... args) {
        Options options = new Options();

        options.addOption("c", "config", true, "path to config file");
        options.addOption("o", "output", true, "config file to write (can be same as source)");
        options.addOption("d", "decrypt", false, "decrypt existing config file");
        options.addOption("h", "help", false, "print help");

        CommandLineParser parser = new GnuParser();
        try {
            CommandLine cmd = parser.parse(options, args, false);

            if (cmd.hasOption("help")) {
                printUsage(options);
                System.exit(0);
            }

            File config = new File(cmd.getOptionValue("config", DEFAULT_SCYLLA_YAML));

            if (!config.isFile()) {
                throw new ConfigurationException(config + " does not exist");
            }
            if (!config.canRead()) {
                throw new ConfigurationException("Cannot read " + config);
            }

            String outName = cmd.getOptionValue("output", null);

            if (outName != null) {
                File output = new File(outName);
                if (output.exists() && !output.canWrite()) {
                    throw new ConfigurationException("Cannot write " + output);
                }
            }

            boolean decrypt = cmd.hasOption("decrypt");

            String[] files = cmd.getArgs();

            if (files.length > 1 && !decrypt) {
                throw new ConfigurationException("Too many arguments");
            }

            // figure out the system key file
            Cipher cipher = null;
            File keyFile = null;

            if (files.length > 0 || !decrypt) {
                keyFile = resolveSystemKey(files.length > 0 ? files[0] : getSystemKeyDir());
                cipher = loadSystemKey(keyFile);
            }

            // Ok, got key and config. Load config.
            String contents = new String(readAllBytes(config.toPath()), "UTF-8");

            Yaml yaml = new Yaml();

            // First check if the config seems encrypted already.

            boolean isEncrypted = false;
            Cipher srcCipher = null;

            Map<?, ?> map = (Map<?, ?>) yaml.load(new StringReader(contents));
            for (Map.Entry<?, ?> e : map.entrySet()) {
                if (CONFIG_ENCRYPTION_ACTIVE.equals(e.getKey())) {
                    isEncrypted = valueOf(e.getValue().toString());
                } else if (CONFIG_ENCRYPTION_KEY_NAME.equals(e.getKey())) {
                    File f = resolveSystemKey(e.getValue().toString());
                    srcCipher = loadSystemKey(f, DECRYPT_MODE);
                }
            }

            if (isEncrypted && srcCipher == null) {
                System.err.println(config + " already encrypted but no key found. Exiting.");
                System.exit(1);
            }

            // This is the tricky part. We want to preserve the yaml file, with
            // comments etc, but not rely on regex matching or similar.
            //
            // We do this by streaming the yaml parser events, looking for
            // "scalar"
            // nodes matching what we see. When we find these, we simply copy
            // all data from last match (or start) up until now, do what we
            // should (replace, encrypt, remove) and the set data offset to this
            // nodes end.
            Iterable<Event> events = yaml.parse(new StringReader(contents));

            StringBuilder buf = new StringBuilder();

            boolean skipNext = false;
            boolean encryptNext = false;
            boolean didEncrypt = false;
            int off = 0;

            for (Event e : events) {
                if (!e.is(ID.Scalar)) {
                    continue;
                }

                String append = null;
                ScalarEvent scalar = (ScalarEvent) e;
                boolean skipPrev = false;

                if (encryptNext) {
                    // encrypt (or decrypt) this node
                    encryptNext = false;
                    String v = scalar.getValue();
                    byte bytes[];
                    // is the file already encrypted?
                    if (isEncrypted) {
                        byte src[] = Base64.getDecoder().decode(v);
                        bytes = srcCipher.doFinal(src);
                    } else {
                        bytes = v.getBytes("UTF-8");
                    }
                    // In decrypt case we don't (re-)encrypt the value
                    if (cipher != null) {
                        byte[] encrypted = cipher.doFinal(bytes);
                        append = Base64.getEncoder().encodeToString(encrypted);
                        didEncrypt = true;
                    } else {
                        append = new String(bytes, "UTF-8");
                    }
                } else if (skipNext) {
                    // remove this node from the result tree
                    append = "";
                    skipPrev = true;
                    skipNext = false;
                } else {
                    String value = scalar.getValue();
                    for (String s : ENCRYPTED_ENTRIES) {
                        // found key for encrypted value. Next event will
                        // need encryption.
                        if (value.equals(s)) {
                            encryptNext = true;
                            break;
                        }
                    }
                    // remove existing crypto config parameters
                    if (value.equals(CONFIG_ENCRYPTION_ACTIVE) || value.equals(CONFIG_ENCRYPTION_KEY_NAME)) {
                        skipNext = true;
                        append = "";
                    }
                }

                if (append != null) {
                    if (!skipPrev) {
                        buf.append(contents, off, e.getStartMark().getIndex());
                    }
                    buf.append(append);
                    off = e.getEndMark().getIndex();
                }
            }

            // copy all remaining text.
            buf.append(contents, off, contents.length());
            // maybe remove old "generated" comment
            int i = buf.indexOf(GENERATED_BY_CONFIG_ENCRYPTOR);
            if (i != -1) {
                buf.replace(i, i + GENERATED_BY_CONFIG_ENCRYPTOR.length(), "");
            }

            // if we added encrypted entries, we must also append
            // encryption parameters to the result.
            if (didEncrypt) {
                Path sysKeyDir = Paths.get(getSystemKeyDir()).toAbsolutePath();
                Path key = sysKeyDir.relativize(keyFile.toPath());

                buf.append(GENERATED_BY_CONFIG_ENCRYPTOR).append(CONFIG_ENCRYPTION_ACTIVE).append(": True\n")
                        .append(CONFIG_ENCRYPTION_KEY_NAME).append(": ").append(key.toString());
            }

            PrintStream out = System.out;

            if (outName != null) {
                File f = new File(outName);
                if (!f.exists()) {
                    Files.createFile(f.toPath(), asFileAttribute(of(OWNER_READ, OWNER_WRITE)));
                }
                out = new PrintStream(new FileOutputStream(f));
            }

            out.println(buf.toString());
            out.flush();
        } catch (ParseException | ConfigurationException e) {
            System.err.println(e.getMessage());
            printUsage(options);
            System.exit(1);
        } catch (Exception e) {
            e.printStackTrace();
            System.err.println(e.getMessage());
            System.exit(1);
        }
    }
}
